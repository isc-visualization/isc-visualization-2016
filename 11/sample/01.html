<!DOCTYPE html>
<html lang="kr">

<head>
    <meta charset="utf-8">
    <title>D3 페이지 템플릿</title>
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <style>

    </style>
</head>

<body>
</svg>
    <script type="text/javascript">
    d3.json('flare.json', callback);

    function callback(err, data) {
      if(err) return console.error(err);
      console.log(data);
      var hierarchy = d3.hierarchy(data, function(d){return d.children});
      console.log(hierarchy);
      hierarchy.sum(function(d){return d.size})
      console.log(hierarchy);
      hierarchy.sort(function(a, b) {
        return b.height - a.height || b.value - a.value ;
      }) // expr1 || expr2 일때 expr1이 falsy value면 다음 값을 뱉어냄

      var w = 600, h = 300;
      var margin = {top:10, right:10, bottom: 10, left: 10};
      var innerW = w - margin.right - margin.left,
        innerH = h - margin.top - margin.bottom;

      var svg = d3.select('body').append('svg')
          .attr('width', w)
          .attr('height', h)
        .append('g')
          .attr('transform', 'translate('+ [margin.left, margin.top] + ')');
      var paddingTop = 16;
      var pack  = d3.pack()
        .size([innerW, innerH])

        hierarchy = pack(hierarchy);
      var opacityDomain = d3.extent(hierarchy.leaves(), function(d){return d.value;});
      var opacity = d3.scaleLinear().domain(opacityDomain).range([0.4, 1.0]);
      var colorDomain = hierarchy.children.map(function(d){return d.data.name});
      var color = d3.scaleOrdinal().domain(colorDomain).range(d3.schemeCategory10);

      var nodes = hierarchy.descendants();

      var leaf = svg.selectAll('.leaf')
        .data(nodes.filter(function(n){return !n.children}), function(d){return d.data.name})
        .enter().append('circle')
          .attr('class', 'leaf')
        .attr('cx', function(d){return d.x})
        .attr('cy', function(d){return d.y})
        .attr('r', function(d){return d.r})
        // .attr('width', function(d){return d.x1-d.x0})
        // .attr('height', function(d){return d.y1-d.y0})
        .style('fill-opacity', function(d){return opacity(d.value)})
        .style('fill', function(d){return color(findParent(d, 1).data.name)});

      // var parent = svg.selectAll('.parent')
      //     .data(nodes.filter(function(n){return n.children}), function(d){return d.data.name})
      //     .enter().append('g')
      //       .attr('class', 'parent')
      //       .attr('transform', function(d){return 'translate(' +[d.x0, d.y0] + ')'})
      //   parent.append('rect')
      //     .attr('width', function(d){return d.x1-d.x0;})
      //     .attr('height', function(d){return paddingTop;})
      //     .style('fill', '#ddd')
      //     .style('stroke', '#ccc')
      //   parent.append('text')
      //     .text(function(d){return d.data.name})
      //     .attr('dy', function(d){return '1em'})
      //     .style('font-size', '12px')
      //     .style('font-family', 'sans-serif')
    }
    function findParent(node, depth) {

      if(node.depth < depth) {
        return null;
      } else if(node.depth === depth) {
        return node;
      }
      if(node.parent) {
        return findParent(node.parent, depth); //재귀 recursion
      }
    }




    </script>
</body>

</html>
